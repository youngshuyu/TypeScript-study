// 使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript支持数字的和基于字符串的枚举。
// 数字枚举
enum Direction1 {
  UP = 1, // 不写值默认从0开始
  Down,
  Left,
  Right,
}
// 如上，我们定义了一个数字枚举， Up使用初始化为 1。 其余的成员会从 1开始自动增长。 换句话说， Direction.Up的值为 1， Down为 2， Left为 3， Right为 4。

// 字符串枚举
// 字符串枚举的概念很简单，但是有细微的 运行时的差别。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。
enum Direction2 {
  Up = "UP",
  Down = "DOWN",
  Left = "LEFT",
  Right = "RIGHT",
}
// 由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管 反向映射会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。

// 异构枚举
// 可以混合字符串和数字（一般不建议这样做）
enum Types {
  Yes = 1,
  No = "No",
}

// 接口枚举
// 声明对象的时候要遵守这个规则
interface A {
  answer: Types.Yes;
}
const a: A = {
  answer: Types.Yes,
};

// const枚举
// let和var都是不允许的声明，只能用const
// 大多数情况下，枚举是十分有效的方案。 然而在某些情况下需求很严格。 为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 const枚举。 常量枚举通过在枚举上使用 const修饰符来定义。
const enum Type {
  A = "A",
  B = "B",
}
// const 声明的枚举会被编译为常量，普通声明的枚举编译完后是对象

// 反向映射
// 它包含了正向映射（ name -> value）和反向映射（ value -> name）。 引用枚举成员总会生成为对属性访问并且永远也不会内联代码。
// 要注意的是 不会为字符串枚举成员生成反向映射。
enum Enum {
  AA,
}
let aa = Enum.AA;
let nameOfA = Enum[aa]; // "A"
